<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Event Horizon Salvager</title>
<style>
  html, body { margin:0; height:100%; background:#000; color:#ddd; font-family:system-ui, sans-serif; }
  #ui { position:fixed; top:10px; left:10px; background:rgba(0,0,0,.5); padding:8px 10px; border:1px solid #333; border-radius:8px; }
  #ui b { color:#fff; }
  #msg { position:fixed; bottom:14px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.6); padding:6px 10px; border:1px solid #333; border-radius:8px; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="ui">
  <div>Score: <b id="score">0</b></div>
  <div>Inventory: <b id="inv">0</b></div>
  <div>Horizon Proximity: <b id="prox">OK</b></div>
  <div>Controls: WASD move, QE strafe, SPACE tractor</div>
</div>
<div id="msg">Collect loot and don’t cross the red ring.</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
const W = window.innerWidth, H = window.innerHeight;
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.0025);

const camera = new THREE.PerspectiveCamera(70, W/H, 0.1, 2000);
camera.position.set(0, 20, 55);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(W, H);
document.body.appendChild(renderer.domElement);

// Lights
const hemi = new THREE.HemisphereLight(0x556677, 0x000000, 0.9);
scene.add(hemi);
const key = new THREE.PointLight(0xffffff, 1.5, 300);
key.position.set(0, 0, 0);
scene.add(key);

// Black hole (visual): dark sphere + emissive disk + red “horizon” ring
const BH_RADIUS = 6;
const bhGeo = new THREE.SphereGeometry(BH_RADIUS, 32, 32);
const bhMat = new THREE.MeshStandardMaterial({ color:0x000000, metalness:1, roughness:0.2, emissive:0x000000 });
const blackHole = new THREE.Mesh(bhGeo, bhMat);
scene.add(blackHole);

// Horizon ring
const HORIZON_R = 14;
const ringGeo = new THREE.RingGeometry(HORIZON_R-0.1, HORIZON_R+0.1, 64);
const ringMat = new THREE.MeshBasicMaterial({ color:0xff0033, side:THREE.DoubleSide });
const ring = new THREE.Mesh(ringGeo, ringMat);
ring.rotation.x = -Math.PI/2;
scene.add(ring);

// Accretion disk (particles)
function makeDiskParticles(n=800) {
  const g = new THREE.BufferGeometry();
  const positions = new Float32Array(n*3);
  const ranges = new Float32Array(n);
  for (let i=0;i<n;i++) {
    const r = THREE.MathUtils.lerp(BH_RADIUS+1.5, HORIZON_R-0.8, Math.random());
    const a = Math.random()*Math.PI*2;
    positions[i*3] = Math.cos(a)*r;
    positions[i*3+1] = (Math.random()-0.5)*0.4;
    positions[i*3+2] = Math.sin(a)*r;
    ranges[i] = r;
  }
  g.setAttribute('position', new THREE.BufferAttribute(positions,3));
  g.setAttribute('range', new THREE.BufferAttribute(ranges,1));
  const m = new THREE.PointsMaterial({ size:0.06, color:0xffaa66 });
  const p = new THREE.Points(g, m);
  p.userData.rotate = true;
  return p;
}
const disk = makeDiskParticles();
scene.add(disk);

// Floor stars
{
  const g = new THREE.BufferGeometry();
  const n=600, arr = new Float32Array(n*3);
  for (let i=0;i<n;i++){
    arr[i*3] = THREE.MathUtils.randFloatSpread(600);
    arr[i*3+1] = THREE.MathUtils.randFloatSpread(8)-4;
    arr[i*3+2] = THREE.MathUtils.randFloatSpread(600);
  }
  g.setAttribute('position', new THREE.BufferAttribute(arr,3));
  scene.add(new THREE.Points(g, new THREE.PointsMaterial({ size:0.8 })));
}

// Player ship
const shipGeo = new THREE.ConeGeometry(1.1, 2.2, 5);
const shipMat = new THREE.MeshStandardMaterial({ color:0x77c7ff, metalness:0.3, roughness:0.4 });
const ship = new THREE.Mesh(shipGeo, shipMat);
ship.rotation.x = Math.PI/2;
ship.position.set(0, 0.7, 28);
scene.add(ship);
let vShip = new THREE.Vector3();

// Tractor beam (visual cone)
const beamGeo = new THREE.ConeGeometry(3.5, 12, 20, 1, true);
const beamMat = new THREE.MeshBasicMaterial({ color:0x77ddff, wireframe:true, transparent:true, opacity:0.35 });
const beam = new THREE.Mesh(beamGeo, beamMat);
beam.rotation.x = Math.PI/2;
beam.position.y = 0.7;
beam.visible = false;
ship.add(beam);

// Debris
const debris = [];
const LOOT_TYPES = {
  Common:   { value:10,  color:0x8fa3b0 },
  Uncommon: { value:25,  color:0x5fd1a5 },
  Rare:     { value:60,  color:0xffd166 },
  Relic:    { value:120, color:0xef476f }
};
const lootKeys = Object.keys(LOOT_TYPES);

function spawnDebris(count=50){
  for(let i=0;i<count;i++){
    const tier = lootKeys[Math.floor(Math.random()*lootKeys.length)];
    const r = THREE.MathUtils.lerp(HORIZON_R+6, 80, Math.random()); // start outside horizon
    const a = Math.random()*Math.PI*2;
    const mesh = new THREE.Mesh(
      new THREE.IcosahedronGeometry(THREE.MathUtils.lerp(0.25,0.8,Math.random()), 0),
      new THREE.MeshStandardMaterial({ color: LOOT_TYPES[tier].color, metalness:0.2, roughness:0.6 })
    );
    mesh.position.set(Math.cos(a)*r, THREE.MathUtils.randFloatSpread(1.2), Math.sin(a)*r);
    mesh.userData = { v:new THREE.Vector3(), tier, value: LOOT_TYPES[tier].value };
    scene.add(mesh);
    debris.push(mesh);
  }
}
spawnDebris();

// Input
const keys = {};
window.addEventListener('keydown', e => keys[e.code]=true);
window.addEventListener('keyup',   e => keys[e.code]=false);

// UI
const uiScore = document.getElementById('score');
const uiInv   = document.getElementById('inv');
const uiProx  = document.getElementById('prox');
let score=0, inventory=0, gameOver=false;

// Helpers
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function dist2(a,b){ return a.distanceToSquared(b); }

// Game constants (feel > realism)
const G = 160;               // gravity strength
const MAX_ACCEL = 0.35;
const DRAG = 0.992;
const THRUST = 0.045;
const STRAFE = 0.035;
const TRACTOR_ON = () => !!keys['Space'];

function applyGravity(pos, vel) {
  const dir = new THREE.Vector3().copy(blackHole.position).sub(pos);
  const r2 = Math.max(dir.lengthSq(), 1.0);
  dir.normalize();
  const a = Math.min(MAX_ACCEL, G / r2);
  vel.addScaledVector(dir, a);
}

// Cone check from ship forward
function inTractorCone(obj){
  const fwd = new THREE.Vector3(0,1,0).applyQuaternion(ship.quaternion); // ship "forward" in +Y after rotation.x
  const toObj = new THREE.Vector3().subVectors(obj.position, ship.position);
  const d = toObj.length();
  if (d > 12) return false;
  const angle = fwd.angleTo(toObj.normalize());
  return angle < THREE.MathUtils.degToRad(18);
}

// Main loop
let last = performance.now();
function tick(now){
  const dt = clamp((now - last)/16.666, 0.2, 2.5); // normalize to ~60fps units
  last = now;

  if (!gameOver){
    // Input forces
    const local = new THREE.Vector3(0,0,0);
    if (keys['KeyW']) local.y += THRUST;
    if (keys['KeyS']) local.y -= THRUST*0.8;
    if (keys['KeyA']) local.x -= STRAFE;
    if (keys['KeyD']) local.x += STRAFE;
    if (keys['KeyQ']) local.z -= STRAFE;
    if (keys['KeyE']) local.z += STRAFE;

    // Transform local to world relative to ship orientation (simple: ship always faces +Y)
    vShip.addScaledVector(local, dt);

    // Gravity & drag
    applyGravity(ship.position, vShip);
    vShip.multiplyScalar(Math.pow(DRAG, dt));

    // Move ship
    ship.position.addScaledVector(vShip, dt);

    // Update beam
    beam.visible = TRACTOR_ON();

    // Debris update
    for (let i=debris.length-1; i>=0; i--){
      const d = debris[i];
      const uv = d.userData.v;

      // Gravity on debris
      applyGravity(d.position, uv);
      uv.multiplyScalar(Math.pow(DRAG, dt));
      d.position.addScaledVector(uv, dt);
      d.rotation.x += 0.01*dt;
      d.rotation.y += 0.008*dt;

      // Tractor pull
      if (beam.visible && inTractorCone(d)){
        const pull = new THREE.Vector3().subVectors(ship.position, d.position).setLength(0.12*dt);
        d.position.add(pull);
      }

      // Collect?
      if (d.position.distanceTo(ship.position) < 1.2){
        score += d.userData.value;
        inventory++;
        uiScore.textContent = score;
        uiInv.textContent = inventory;
        scene.remove(d);
        debris.splice(i,1);
      }

      // Fell past horizon?
      if (d.position.length() < HORIZON_R - 0.2){
        // Just drop it (missed loot)
        scene.remove(d);
        debris.splice(i,1);
      }
    }

    // Danger check
    const shipR = ship.position.length();
    if (shipR < HORIZON_R){
      gameOver = true;
      uiProx.textContent = "PAST HORIZON";
      document.getElementById('msg').textContent = "You crossed the horizon. Press R to restart.";
    } else if (shipR < HORIZON_R + 4){
      uiProx.textContent = "DANGEROUS";
    } else {
      uiProx.textContent = "OK";
    }

    // Respawn debris to keep play density
    if (debris.length < 45) spawnDebris(8);

    // Disk spin
    if (disk.userData.rotate){
      disk.rotation.y += 0.0025*dt;
    }
  }

  // Camera: slow follow distance
  camera.position.lerp(new THREE.Vector3(ship.position.x*0.2, 20, 55), 0.04);
  camera.lookAt(0,0,0);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// Restart
window.addEventListener('keydown', (e)=>{
  if (e.code==='KeyR' && gameOver) location.reload();
});

// Resize
window.addEventListener('resize', ()=>{
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
});
</script>
</body>
</html>